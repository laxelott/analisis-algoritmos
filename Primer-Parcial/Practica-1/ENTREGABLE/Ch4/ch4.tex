\chapter{Conclusiones}

\section{Conclusiones Generales}
    Concluimos que el analisis para un algoritmo es una práctica que debería aplicarse en cualquier algoritmo para poder conocer que tan viable y que tan certera es la respuesta dada. 
    Presentamos dificultades dentro del primer algoritmo a la hora de analizar los pasos que daban los ciclos dentro del código, esto lo resolvimos contando cada iteración dentro de nuestra función.
    Una vez que despejamos la mente, nos dimos cuenta que el segundo algoritmo puede realizarse con una función recursiva, que funciona de manera similar al ciclo while. No decidimos probar esta manera ya que aún no sabemos como manejar una analisis concreto a una función recursiva. 

\newpage
\section{Isaac Sánchez - Conclusiones}
    Esta práctica resulto para mi un tanto complicada ya que no estaba familiarizado con los conceptos de complejidad y estaba un poco oxidado en programar. Al termino de la práctica los conceptos quedaron mas claros gracias al algoritmo de Euclides, este con complejidad log(n) me ayudo comprender porque un algoritmo es menos viable.
    \begin{figure}[htp!]
            \centering
            \includegraphics[width=1 \textwidth]{Images/Fotos_Alumnos/274612600_2528992867236334_6677874837890685705_n.jpg}  
            \caption{Isaac Sánchez}
            \label{fig:my_label}
        \end{figure}
    


\newpage
\section{Axel Trevino - Conclusiones}
    La complejidad es una buena medida (inversa) de qué tan eficiente es un programa, y esto se puede ver en las gráficas: un algoritmo simple y sin eficientizar -el ejercicio 1- tuvo una complejidad de O(n$\wedge2$), mientras que un algoritmo eficientizado -el de Euclides- bajó a log(n), incluso si el primero si tiene mejor caso y no el segundo.
    
    \begin{figure}[htp!]
            \centering
            \includegraphics[width=0.4 \textwidth]{Images/Fotos_Alumnos/axel.jpg}  
            \caption{Axel Treviño}
            \label{fig:my_label}
        \end{figure}
